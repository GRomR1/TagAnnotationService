Процессы и потоки
Теперь мы перейдем к подробному рассмотрению разработки и устройства операционных
систем. Основным понятием в любой операционной системе является процесс:
абстракция, описывающая выполняющуюся программу. Все остальное зависит от этого
понятия, поэтому крайне важно, чтобы разработчики операционных систем (а также
студенты) получили полное представление о концепции процесса как можно раньше.
Процессы — это одна из самых старых и наиболее важных абстракций, присущих
операционной системе. Они поддерживают возможность осуществления (псевдо) параллельных
операций даже при наличии всего одного центрального процессора. Они
превращают один центральный процессор в несколько виртуальных. Без абстракции
процессов современные вычисления просто не могут существовать. В этой главе мы
углубимся во многие подробности, касающиеся процессов и их ближайших родственников
— потоков.
2.1. Процессы
Современные компьютеры, как правило, заняты сразу несколькими делами. Возможно,
люди, привыкшие к работе с компьютерами, не до конца осознают этот факт, поэтому
рассмотрим ряд примеров. Сначала представим себе веб-сервер. К нему отовсюду
приходят запросы, требующие предоставления веб-страниц. Когда приходит запрос,
сервер проверяет, нет ли нужной страницы в кэше. Если она там присутствует, он
отправляет эту страницу; если ее там нет, осуществляется запрос к диску для ее извлечения.
Но с точки зрения центрального процессора запрос информации с диска
занимает целую вечность. За время ожидания результатов запроса информации с диска
может поступить множество других запросов. Если в системе установлено несколько
дисков, то некоторые из новых запросов или все они могут быть направлены на другие
диски задолго до того, как будет удовлетворен первый запрос. Понятно, что нужен
какой-нибудь способ, чтобы смоделировать эту параллельную работу и управлять ею.
Справиться с этим помогают процессы (и особенно потоки).
Теперь рассмотрим персональный компьютер. При запуске системы запускается множество
процессов, о которых пользователь зачастую даже и не подозревает. Например,
может быть запущен процесс, ожидающий входящей электронной почты. Другой запущенный
процесс может принадлежать антивирусной программе и предназначаться для
периодической проверки доступности определений каких-нибудь новых вирусов. В дополнение
к этому могут быть запущены процессы, инициированные пользователем в явном
виде, — печать файлов или сброс пользовательских фотографий на USB-накопитель,
и все они работают одновременно с браузером, с помощью которого пользователь просматривает
Интернет. Всей этой работой нужно управлять, и здесь нам очень пригодится
многозадачная система, поддерживающая работу нескольких процессов.
В любой многозадачной системе центральный процессор быстро переключается
между процессами, предоставляя каждому из них десятки или сотни миллисекунд.
При этом хотя в каждый конкретный момент времени центральный процессор работает
только с одним процессом, в течение 1 секунды он может успеть поработать
с несколькими из них, создавая иллюзию параллельной работы. Иногда в этом случае
говорят о псевдопараллелизме в отличие от настоящего аппаратного параллелизма
в многопроцессорных системах (у которых имеется не менее двух центральных процессоров,
использующих одну и ту же физическую память). Людям довольно трудно
отслеживать несколько действий, происходящих параллельно. Поэтому разработчики
операционных систем за прошедшие годы создали концептуальную модель последовательных
процессов, упрощающую работу с параллельными вычислениями. Эта модель,
ее применение и некоторые последствия ее применения и станут темой данной главы.
2.1.1. Модель процесса
В этой модели все выполняемое на компьютере программное обеспечение, иногда
включая операционную систему, сведено к ряду последовательных процессов, или, для
краткости, просто процессов. Процесс — это просто экземпляр выполняемой программы,
включая текущие значения счетчика команд, регистров и переменных. Концептуально
у каждого процесса есть свой, виртуальный, центральный процессор. Разумеется,
на самом деле настоящий центральный процессор постоянно переключается между
процессами, но чтобы понять систему, куда проще думать о наборе процессов, запущенных
в (псевдо) параллельном режиме, чем пытаться отслеживать, как центральный
процессор переключается между программами. Это постоянное переключение между
процессами, как мы уяснили в главе 1, называется мультипрограммированием, или
многозадачным режимом работы.
На рис. 2.1, а показан компьютер, работающий в многозадачном режиме и имеющий
в памяти четыре программы. На рис. 2.1, б показаны четыре процесса, каждый из
которых имеет собственный алгоритм управления (то есть собственный логический
счетчик команд) и работает независимо от всех остальных. Понятно, что на самом деле
имеется только один физический счетчик команд, поэтому при запуске каждого процесса
его логический счетчик команд загружается в реальный счетчик. Когда работа
с процессом будет на некоторое время прекращена, значение физического счетчика
команд сохраняется в логическом счетчике команд, размещаемом процессом в памяти.
На рис. 2.1, в показано, что за довольно длительный период наблюдения продвинулись
вперед все процессы, но в каждый отдельно взятый момент времени реально работает
только один процесс.
В этой главе мы будем исходить из того, что в нашем распоряжении имеется
лишь один центральный процессор. Хотя все чаще такие предположения противоречат
истине, поскольку новые кристаллы зачастую являются многоядерными,
имеющими два, четыре и большее число ядер. Многоядерным кристаллам
и мультипроцессорам будет в основном посвящена глава 8, но сейчас нам проще
думать, что в конкретный момент времени работает только один центральный
процессор. Поэтому, когда мы говорим, что центральный процессор в действительности
способен в конкретный момент времени работать только с одним процессом,
то если он обладает двумя ядрами (или центральными процессорами), на каждом
из них в конкретный момент времени может запускаться только один процесс.
Рис. 2.1. Компьютер: а — четыре программы, работающие в многозадачном режиме;
б — концептуальная модель четырех независимых друг от друга последовательных процессов;
в — в отдельно взятый момент активна только одна программа
Поскольку центральный процессор переключается между процессами, скорость,
с которой процесс выполняет свои вычисления, не будет одинаковой и, скорее всего,
не сможет быть вновь показана, если тот же процесс будет запущен еще раз. Поэтому
процессы не должны программироваться с использованием каких-либо жестко заданных
предположений относительно времени их выполнения. Рассмотрим, к примеру,
аудиопроцесс, проигрывающий музыку для сопровождения высококачественного
видео, запущенного на другом устройстве. Поскольку аудио может быть запущено
немного позднее видео, аудиопроцесс сигнализирует видеосерверу о пуске проигрывания,
а затем перед проигрыванием аудио запускает холостой цикл 10 000 раз.
Если цикл послужит надежным таймером, то все пройдет как надо, но если же при
выполнении холостого цикла процессор решит переключиться на другой процесс,
аудиопроцесс может возобновиться, когда соответствующие кадры уже будут показаны,
и, к сожалению, синхронизация видео и аудио будет сбита. Когда у процесса
есть подобные критичные для его работы требования, касающиеся реального масштаба
времени, то через определенное количество миллисекунд должны происходить
конкретные события, и для того чтобы они произошли, должны быть предприняты
специальные меры. Но, как правило, на большинство процессов не влияют ни установленный
режим многозадачности центрального процессора, ни относительные
скорости выполнения различных процессов.
Разница между процессом и программой довольно тонкая, но весьма существенная.
Здесь нам, наверное, поможет какая-нибудь аналогия. Представим себе программиста,
решившего заняться кулинарией и испечь пирог на день рождения дочери. У него есть
рецепт пирога, а на кухне есть все ингредиенты: мука, яйца, сахар, ванильный экстракт
и т. д. В данной аналогии рецепт — это программа (то есть алгоритм, выраженный в некой
удобной форме записи), программист — это центральный процессор, а ингредиенты
пирога — это входные данные. Процесс — это действия, состоящие из чтения рецепта
нашим кулинаром, выбора ингредиентов и выпечки пирога.
Теперь представим, что на кухню вбегает сын программиста и кричит, что его ужалила
пчела. Программист записывает, на каком месте рецепта он остановился (сохраняется
состояние текущего процесса), достает книгу советов по оказанию первой помощи
и приступает к выполнению изложенных в ней инструкций. Перед нами процессор,
переключенный с одного процесса (выпечки) на другой процесс, имеющий более высокую
степень приоритета (оказание медицинской помощи), и у каждого из процессов
есть своя программа (рецепт против справочника по оказанию первой помощи). После
извлечения пчелиного жала программист возвращается к пирогу, продолжая выполнять
действия с того места, на котором остановился.
Ключевая идея здесь в том, что процесс — это своего рода действия. У него есть программа,
входные и выходные данные и состояние. Один процессор может совместно
использоваться несколькими процессами в соответствии с неким алгоритмом планирования,
который используется для определения того, когда остановить один процесс
и обслужить другой. В отличие от процесса программа может быть сохранена на диске
и вообще ничего не делать.
Стоит отметить, что если программа запущена дважды, то считается, что ею заняты два
процесса. Например, зачастую возможно дважды запустить текстовый процессор или
одновременно распечатать два файла, если одновременно доступны два принтера. Тот
факт, что два работающих процесса запущены от одной и той же программы, во внимание
не принимается, поскольку это два разных процесса. Операционная система может
позволить им использовать общий код, поэтому в памяти будет присутствовать только
одна копия этого кода, но это чисто техническая деталь, не меняющая концептуальную
ситуацию, касающуюся двух работающих процессов.
2.1.2. Создание процесса
Операционным системам необходим какой-нибудь способ для создания процессов.
В самых простых системах или в системах, сконструированных для запуска только
одного приложения (например, в контроллере микроволновой печи), появляется возможность
присутствия абсолютно всех необходимых процессов при вводе системы
в действие. Но в универсальных системах нужны определенные способы создания
и прекращения процессов по мере необходимости.
Существуют четыре основных события, приводящих к созданию процессов.
1. Инициализация системы.
2. Выполнение работающим процессом системного вызова, предназначенного для
создания процесса.
3. Запрос пользователя на создание нового процесса.
4. Инициация пакетного задания.
При запуске операционной системы создаются, как правило, несколько процессов.
Некоторые из них представляют собой высокоприоритетные процессы, то есть процессы,
взаимодействующие с пользователями и выполняющие для них определенную
работу. Остальные являются фоновыми процессами, не связанными с конкретными
пользователями, но выполняющими ряд специфических функций. Например, фоновый
процесс, который может быть создан для приема входящих сообщений электронной
почты, основную часть времени проводит в спящем режиме, активизируясь
только по мере появления писем. Другой фоновый процесс, который может быть
создан для приема входящих запросов на веб-страницы, размещенные на машине,
просыпается при поступлении запроса с целью его обслуживания. Фоновые процессы,
предназначенные для обработки какой-либо активной деятельности, связанной,
например, с электронной почтой, веб-страницами, новостями, выводом информации
на печать и т. д., называются демонами. Обычно у больших систем насчитываются
десятки демонов. В UNIX 1 для отображения списка запущенных процессов может
быть использована программа  ps . В Windows для этой цели может использоваться
диспетчер задач.
Вдобавок к процессам, созданным во время загрузки, новые процессы могут быть созданы
и после нее. Часто бывает так, что работающий процесс осуществляет системный
вызов для создания одного или более новых вспомогательных процессов. Создание
новых процессов особенно полезно, когда выполняемая работа может быть легко выражена
в понятиях нескольких связанных друг с другом, но в остальном независимых
друг от друга взаимодействующих процессов. Например, если из сети выбирается
большой объем данных для последующей обработки, наверное, будет удобно создать
один процесс для выборки данных и помещения их в общий буфер, чтобы в то же самое
время второй процесс забирал элементы данных и проводил их обработку. Также
можно ускорить выполнение работы, если на многопроцессорной системе разрешить
каждому процессу работать на разных центральных процессорах.
В интерактивных системах пользователи могут запустить программу вводом команды
или щелчком (двойным щелчком) на значке. Любое из этих действий дает начало новому
процессу и запускает в нем выбранную программу. В основанных на применении
команд UNIX-системах с работающей X-оболочкой новый процесс получает окно,
в котором он был запущен. При запуске в Microsoft Windows процесс не имеет окна,
но он может создать одно или несколько окон, и в большинстве случаев так и происходит.
В обеих системах пользователи могут одновременно открыть несколько окон,
в каждом из которых запущен какой-нибудь процесс. Используя мышь, пользователь
может выбрать окно и взаимодействовать с процессом, например, если потребуется,
вводить данные.
Последнее событие, приводящее к созданию процесса, применимо только к системам
пакетной обработки данных, имеющимся на больших универсальных машинах. Представьте
себе управление запасами товаров в конце рабочего дня в сети магазинов. Здесь
пользователи могут отправлять системе пакетные задания (возможно, с помощью удаленного
доступа). Когда операционная система решает, что у нее достаточно ресурсов
для запуска еще одного задания, она создает новый процесс и запускает новое задание
из имеющейся у нее очереди входящих заданий.
С технической точки зрения во всех этих случаях новый процесс создается за счет уже
существующего процесса, который выполняет системный вызов, предназначенный для
создания процесса. Этим процессом может быть работающий пользовательский процесс,
системный процесс, вызванный событиями клавиатуры или мыши, или процесс
управления пакетными заданиями. Данный процесс осуществляет системный вызов
для создания нового процесса. Этот системный вызов предписывает операционной
системе создать новый процесс и прямо или косвенно указывает, какую программу
в нем запустить.
В UNIX существует только один системный вызов для создания нового процесса —
fork. Этот вызов создает точную копию вызывающего процесса. После выполнения
системного вызова fork два процесса, родительский и дочерний, имеют единый образ
1 В этой главе под UNIX следует подразумевать практически все системы, основанные на
POSIX, включая Linux, FreeBSD, OS X, Solaris и т. д., и, за некоторым исключением, также
Android и iOS.
памяти, единые строки описания конфигурации и одни и те же открытые файлы.
И больше ничего. Обычно после этого дочерний процесс изменяет образ памяти
и запускает новую программу, выполняя системный вызов execve или ему подобный.
Например, когда пользователь набирает в оболочке команду sort, оболочка создает ответвляющийся
дочерний процесс, в котором и выполняется команда sort. Смысл этого
двухступенчатого процесса заключается в том, чтобы позволить дочернему процессу
управлять его файловыми дескрипторами после разветвления, но перед выполнением
execve с целью выполнения перенаправления стандартного ввода, стандартного вывода
и стандартного вывода сообщений об ошибках.
В Windows все происходит иначе: одним вызовом функции Win32 CreateProcess
создается процесс, и в него загружается нужная программа. У этого вызова имеется
10 параметров, включая выполняемую программу, параметры командной строки
для этой программы, различные параметры безопасности, биты, управляющие наследованием
открытых файлов, информацию о приоритетах, спецификацию окна,
создаваемого для процесса (если оно используется), и указатель на структуру, в которой
вызывающей программе будет возвращена информация о только что созданном
процессе. В дополнение к функции CreateProcess в Win32 имеется около 100 других
функций для управления процессами и их синхронизации, а также выполнения всего,
что с этим связано.
В обеих системах, UNIX и Windows, после создания процесса родительский и дочерний
процессы обладают своими собственными, отдельными адресными пространствами.
Если какой-нибудь процесс изменяет слово в своем адресном пространстве, другим
процессам эти изменения не видны. В UNIX первоначальное состояние адресного пространства
дочернего процесса является копией адресного пространства родительского
процесса, но это абсолютно разные адресные пространства — у них нет общей памяти,
доступной для записи данных. Некоторые реализации UNIX делят между процессами
текст программы без возможности его модификации. Кроме того, дочерний процесс
может совместно использовать всю память родительского процесса, но если память совместно
используется в режиме копирования при записи (copy on write), это означает,
что при каждой попытке любого из процессов модифицировать часть памяти эта часть
сначала явным образом копируется, чтобы гарантировать модификацию только в закрытой
области памяти. Следует также заметить, что память, используемая в режиме
записи, совместному использованию не подлежит.
Тем не менее вновь созданный процесс может делить со своим создателем часть других
ресурсов, например открытые файлы. В Windows адресные пространства родительского
и дочернего процессов различаются с самого начала.
2.1.3. Завершение процесса
После создания процесс начинает работать и выполняет свою задачу. Но ничто не длится
вечно, даже процессы. Рано или поздно новые процессы будут завершены, обычно
в силу следующих обстоятельств:
? обычного выхода (добровольно);
? выхода при возникновении ошибки (добровольно);
? возникновения фатальной ошибки (принудительно);
? уничтожения другим процессом (принудительно).
Большинство процессов завершаются по окончании своей работы. Когда компилятор
откомпилирует заданную ему программу, он осуществляет системный вызов, сообщающий
операционной системе о завершении своей работы. Этим вызовом в UNIX является
exit, а в Windows — ExitProcess. Программы, работающие с экраном, также
поддерживают добровольное завершение. Текстовые процессоры, интернет-браузеры
и аналогичные программы всегда содержат значок или пункт меню, на котором пользователь
может щелкнуть, чтобы приказать процессу удалить все временные файлы,
которые им были открыты, и завершить свою работу.
Вторая причина завершения — обнаружение процессом фатальной ошибки. Например,
если пользователь наберет команду
cc foo.c
с целью компиляции программы foo.c, а файла с таким именем не будет, то произойдет
простое объявление о наличии данного факта и выход из компилятора. Выхода из интерактивных,
использующих экран процессов при задании им неверных параметров
обычно не происходит. Вместо этого появляется диалоговое окно с просьбой о повторной
попытке ввода параметров.
Третья причина завершения — ошибка, вызванная самим процессом, чаще всего
связанная с ошибкой в программе. В качестве примеров можно привести неверную
инструкцию, ссылку на несуществующий адрес памяти или деление на нуль. В некоторых
системах (например, UNIX) процесс может сообщить операционной системе
о своем намерении обработать конкретные ошибки самостоятельно, в таком случае,
когда встречается одна из таких ошибок, процесс получает сигнал (прерывается), а не
завершается.
Четвертая причина, из-за которой процесс может быть завершен, — это выполнение
процессом системного вызова, приказывающего операционной системе завершить
некоторые другие процессы. В UNIX этот вызов называется kill. Соответствующая
функция Win32 называется TerminateProcess. В обоих случаях у процесса, вызывающего
завершение, должны быть на это соответствующие полномочия. В некоторых системах
при добровольном или принудительном завершении процесса тут же завершаются и все
созданные им процессы. Но ни UNIX, ни Windows так не делают.
2.1.4. Иерархии процессов
В некоторых системах, когда процесс порождает другой процесс, родительский и дочерний
процессы продолжают оставаться определенным образом связанными друг
с другом. Дочерний процесс может и сам создать какие-нибудь процессы, формируя
иерархию процессов. Следует заметить, что, в отличие от растений и животных, использующих
половую репродукцию, у процесса есть только один родитель (но нуль,
один, два или более детей). Следовательно, процесс больше похож на гидру, чем, скажем,
на корову.
В UNIX процесс, все его дочерние процессы и более отдаленные потомки образуют
группу процессов. Когда пользователь отправляет сигнал с клавиатуры, тот достигает
всех участников этой группы процессов, связанных на тот момент времени с клавиатурой
(обычно это все действующие процессы, которые были созданы в текущем окне).
Каждый процесс по отдельности может захватить сигнал, игнорировать его или совершить
действие по умолчанию, которое должно быть уничтожено сигналом.
В качестве другого примера, поясняющего ту ключевую роль, которую играет иерархия
процессов, давайте рассмотрим, как UNIX инициализирует саму себя при запуске
сразу же после начальной загрузки компьютера. В загрузочном образе присутствует
специальный процесс, называемый init. В начале своей работы он считывает файл,
сообщающий о количестве терминалов. Затем он разветвляется, порождая по одному
процессу на каждый терминал. Эти процессы ждут, пока кто-нибудь не зарегистрируется
в системе. Если регистрация проходит успешно, процесс регистрации порождает
оболочку для приема команд. Эти команды могут породить другие процессы и т. д.
Таким образом, все процессы во всей системе принадлежат единому дереву, в корне
которого находится процесс init.
В отличие от этого в Windows не существует понятия иерархии процессов, и все процессы
являются равнозначными. Единственным намеком на иерархию процессов
можно считать присвоение родительскому процессу, создающему новый процесс, специального
маркера (называемого дескриптором), который может им использоваться
для управления дочерним процессом. Но он может свободно передавать этот маркер
какому-нибудь другому процессу, нарушая тем самым иерархию. А в UNIX процессы
не могут лишаться наследственной связи со своими дочерними процессами.
2.1.5. Состояния процессов
Несмотря на самостоятельность каждого процесса, наличие собственного счетчика
команд и внутреннего состояния, процессам зачастую необходимо взаимодействовать
с другими процессами. Один процесс может генерировать выходную информацию, используемую
другими процессами в качестве входной информации. В команде оболочки
cat chapter1 chapter2 chapter3 | grep tree
первый процесс, запускающий программу cat, объединяет и выдает на выходе содержимое
трех файлов. Второй процесс, запускающий программу grep, выбирает все строки,
в которых содержится слово «tree». В зависимости от относительной скорости этих
двух процессов (которая зависит от двух факторов: относительной сложности программ
и количества выделяемого каждому из них времени работы центрального процессора)
может получиться так, что программа grep готова к работе, но ожидающие ее входные
данные отсутствуют. Тогда она должна блокироваться до поступления входных данных.
Процесс блокируется из-за того, что, по логике, он не может продолжаться, как правило,
потому что ожидает недоступных в настоящий момент входных данных. Может
случиться и так, что останавливается тот процесс, который в принципе готов к работе
и может быть запущен, а причина кроется в том, что операционная система решила на
некоторое время выделить центральный процессор другому процессу. Эти два условия
полностью отличаются друг от друга. В первом случае приостановка порождена какойнибудь
проблемой (вы не можете обработать пользовательскую командную строку,
пока она не будет введена). Во втором случае на первый план выступает техническая
сторона вопроса (не хватает центральных процессоров, чтобы каждому процессу выделить
собственный процессор). На рис. 2.2 показана диаграмма, отображающая три
состояния, в которых может находиться процесс:
? выполняемый (в данный момент использующий центральный процессор);
? готовый (работоспособный, но временно приостановленный, чтобы дать возможность
выполнения другому процессу);
? заблокированный (неспособный выполняться, пока не возникнет какое-нибудь
внешнее событие).
Логически первые два состояния похожи друг на друга. В обоих случаях процесс
желает выполняться, но во втором состоянии временно отсутствует доступный для
этого процессор. Третье состояние коренным образом отличается от первых двух тем,
что процесс не может выполняться, даже если процессору кроме него больше нечем
заняться.
Рис. 2.2. Процесс может быть в выполняемом, заблокированном или готовом состоянии.
Стрелками показаны переходы между этими состояниями
Как показано на рисунке, между этими тремя состояниями могут быть четыре перехода.
Переход 1 происходит в том случае, если операционная система определит, что
процесс в данный момент выполняться не может. В некоторых системах для перехода
в заблокированное состояние процесс может осуществить такой системный вызов,
как pause. В других системах, включая UNIX, когда процесс осуществляет чтение из
канала или специального файла (например, с терминала) и доступные входные данные
отсутствуют, процесс блокируется автоматически.
Переходы 2 и 3 вызываются планировщиком процессов, который является частью
операционной системы, без какого-либо оповещения самого процесса. Переход 2 происходит,
когда планировщик решит, что выполняемый процесс продвинулся достаточно
далеко и настало время позволить другому процессу получить долю рабочего времени
центрального процессора. Переход 3 происходит, когда все другие процессы получили
причитающуюся им долю времени и настал момент предоставить центральный процессор
первому процессу для возобновления его выполнения. Вопрос планирования,
то есть решение, какой именно процесс, когда и сколько времени должен выполняться,
играет весьма важную роль и будет рассмотрен в этой главе чуть позже. В попытках
сбалансировать конкурирующие требования соблюдения эффективности системы
в целом и справедливого отношения к отдельному процессу было изобретено множество
алгоритмов. Некоторые из них еще будут рассмотрены в этой главе.
Переход 4 осуществляется в том случае, если происходит внешнее событие, ожидавшееся
процессом (к примеру, поступление входных данных). Если к этому моменту
нет других выполняемых процессов, будет вызван переход 3 и процесс возобновится.
В противном случае ему придется немного подождать в состоянии готовности, пока не
станет доступен центральный процессор и не придет его очередь.
Использование модели процесса облегчает представление о том, что происходит внутри
системы. Некоторые процессы запускают программу, выполняющую команды, введенные
пользователем. Другие процессы являются частью системы, справляясь с такими
задачами, как выполнение запросов на обслуживание файлов или управление деталями
работы дискового или ленточного привода. Когда происходят дисковые прерывания,
система принимает решение остановить выполнение текущего процесса и запустить
процесс работы с диском, заблокированный в ожидании этого прерывания. Таким образом,
вместо того чтобы думать о прерываниях, мы можем думать о пользовательских
процессах, процессах работы с диском, процессах работы с терминалом и т. д., которые
блокируются, когда ожидают каких-то событий. Когда считана информация с диска
или набран символ, процесс, ожидающий это событие, разблокируется и получает
право на возобновление выполнения.
В результате такого представления возникает модель, показанная на рис. 2.3. На этом
рисунке самым нижним уровнем операционной системы является планировщик, над
которым изображен ряд процессов. Вся обработка прерываний и подробности действий,
запускающих и останавливающих процессы, здесь скрыты под тем, что называется
планировщиком, для реализации которого используется сравнительно небольшой
объем кода. Вся остальная часть операционной системы неплохо структурирована
в виде процессов. Но такой структурой обладает сравнительно небольшое количество
настоящих систем.
Рис. 2.3. Самый низший уровень структурированной в виде процессов
операционной системы обрабатывает прерывания и планирует выполнение процессов.
Выше этого уровня находятся последовательные процессы
2.1.6. Реализация процессов
Для реализации модели процессов операционная система ведет таблицу (состоящую
из массива структур), называемую таблицей процессов, в которой каждая запись соответствует
какому-нибудь процессу. (Ряд авторов называют эти записи блоками управления
процессом.) Эти записи содержат важную информацию о состоянии процесса,
включая счетчик команд, указатель стека, распределение памяти, состояние открытых
им файлов, его учетную и планировочную информацию и все остальное, касающееся
процесса, что должно быть сохранено, когда процесс переключается из состояния выполнения
в состояние готовности или блокировки, чтобы позже он мог возобновить
выполнение, как будто никогда не останавливался.
В табл. 2.1 показан ряд ключевых полей типовой системы. Поля первого столбца
относятся к управлению процессами. Поля остальных двух столбцов относятся
к управлению памятью и файлами соответственно. Следует заметить, что наличие
тех или иных полей в таблице процессов в большей степени зависит от системы, но
в этой таблице изложено основное представление о типе необходимой информации.
Теперь, после изучения таблицы процессов, появилась возможность чуть лучше объяснить,
как создается иллюзия нескольких последовательных процессов, выполняемых
на одном (или на каждом) центральном процессоре. Существует область памяти
(обычно это фиксированная область в нижних адресах), связанная с каждым классом
устройств ввода-вывода, которая называется вектором прерывания. В ней содержится
адрес процедуры, обслуживающей прерывание. Предположим, что при возникновении
дискового прерывания выполнялся пользовательский процесс № 3. Счетчик команд
Таблица 2.1. Некоторые из полей типичной записи таблицы процессов
Управление процессом Управление памятью Управление файлами
Регистры Указатель на информацию
о текстовом сегменте
Корневой каталог
Счетчик команд Указатель на информацию
о сегменте данных
Рабочий каталог
Слово состояния программы Указатель на информацию
о сегменте стека
Дескрипторы файлов
Указатель стека Идентификатор пользователя
Состояние процесса Идентификатор группы
Приоритет
Параметры планирования
Идентификатор процесса
Родительский процесс
Группа процесса
Сигналы
Время запуска процесса
Использованное время процессора
Время процессора, использованное дочерними процессами
Время следующего аварийного сигнала
этого процесса, слово состояния программы, а иногда и один или несколько регистров
помещаются в текущий стек аппаратными средствами прерывания. Затем компьютер
переходит на адрес, указанный в векторе прерывания. На этом работа аппаратных
средств заканчивается и вступает в действие программное обеспечение, а именно процедура
обслуживания прерывания.
Все прерывания сначала сохраняют состояния регистров, зачастую используя для
этого запись текущего процесса в таблице процессов. Затем информация, помещенная
в стек прерыванием, удаляется и указатель стека переустанавливается на временный
стек, используемый обработчиком прерывания. Такие действия, как сохранение регистров
и переустановка указателя стека, не могут быть выражены на языках высокого
уровня (например, C), поэтому они выполняются небольшой подпрограммой на языке
ассемблера, обычно одной и той же для всех прерываний, поскольку характер работы
по сохранению регистров не изменяется, какой бы ни была причина прерывания.
Когда эта подпрограмма завершает свою работу, она вызывает C-процедуру, которая
делает всю остальную работу для данного конкретного типа прерывания. (Мы предполагаем,
что операционная система написана на языке C, который обычно и выбирается
для всех настоящих операционных систем.) Возможно, когда работа этой процедуры
будет завершена, какой-нибудь процесс переходит в состояние готовности к работе
и вызывается планировщик, чтобы определить, какой процесс будет выполняться
следующим. После этого управление передается обратно коду, написанному на языке
ассемблера, чтобы он загрузил для нового текущего процесса регистры и карту памяти
и запустил выполнение этого процесса. Краткое изложение процесса обработки прерывания
и планирования приведено в табл. 2.2. Следует заметить, что детали от системы
к системе могут несколько различаться.
Таблица 2.2. Схема работы низшего уровня операционной системы
при возникновении прерывания
1 Оборудование помещает в стек счетчик команд и т. п.
2 Оборудование загружает новый счетчик команд из вектора прерывания
3 Процедура на ассемблере сохраняет регистры
4 Процедура на ассемблере устанавливает указатель на новый стек
5 Запускается процедура на языке C, обслуживающая прерывание (как правило, она
считывает входные данные и помещает их в буфер)
6 Планировщик принимает решение, какой процесс запускать следующим
7 Процедура на языке C возвращает управление ассемблерному коду
8 Процедура на ассемблере запускает новый текущий процесс
Процесс во время своего выполнения может быть прерван тысячи раз, но ключевая
идея состоит в том, что после каждого прерывания прерванный процесс возвращается
в точности к такому же состоянию, в котором он был до того, как случилось прерывание.
2.1.7. Моделирование режима многозадачности
Режим многозадачности позволяет использовать центральный процессор более рационально.
При грубой прикидке, если для среднестатистического процесса вычисления
занимают лишь 20 % времени его пребывания в памяти, то при пяти одновременно
находящихся в памяти процессах центральный процессор будет загружен постоянно.
Но в эту модель заложен абсолютно нереальный оптимизм, поскольку в ней заведомо
предполагается, что все пять процессов никогда не будут одновременно находиться
в ожидании окончания какого-нибудь процесса ввода-вывода.
Лучше выстраивать модель на основе вероятностного взгляда на использование центрального
процессора. Предположим, что процесс проводит часть своего времени p
в ожидании завершения операций ввода-вывода. При одновременном присутствии
в памяти n процессов вероятность того, что все n процессов ожидают завершения вводавывода
(в случае чего процессор простаивает), равна p n . Тогда время задействования
процессора вычисляется по формуле
Время задействования ценрального процессора = 1 ? p n .
На рис. 2.4 показано время задействования центрального процессора в виде функции
от аргумента n, который называется степенью многозадачности.
Судя по рисунку, если процесс тратит 80 % своего времени на ожидание завершения
ввода-вывода, то для снижения простоя процессора до уровня не более 10 % в памяти
могут одновременно находиться по крайней мере 10 процессов. Когда вы поймете, что
к ожиданию ввода-вывода относится и ожидание интерактивного процесса пользовательского
ввода с терминала (или щелчка кнопкой мыши на значке), станет понятно,
что время ожидания завершения ввода-вывода, составляющее 80 % и более, не такая
уж редкость. Но даже на серверах процессы, осуществляющие множество операций
ввода-вывода, зачастую имеют такой же или даже больший процент простоя.
Справедливости ради следует заметить, что рассмотренная нами вероятностная модель
носит весьма приблизительный характер. В ней безусловно предполагается, что
Рис. 2.4. Время задействования центрального процессора в виде функции
от количества процессов, присутствующих в памяти
все n процессов являются независимыми друг от друга, а значит, в системе с пятью
процессами в памяти вполне допустимо иметь три выполняемых и два ожидающих
процесса. Но имея один центральный процессор, мы не может иметь сразу три выполняемых
процесса, поэтому процесс, который становится готовым к работе при занятом
центральном процессоре, вынужден ожидать своей очереди. Из-за этого процессы не
обладают независимостью. Более точная модель может быть выстроена с использованием
теории очередей, но сделанный нами акцент на многозадачность, позволяющую
загружать процессор во избежание его простоя, по-прежнему сохраняется, даже если
реальные кривые немного отличаются от тех, что показаны на рис. 2.4.
Несмотря на упрощенность модели, представленной на рис. 2.4, тем не менее она
может быть использована для специфических, хотя и весьма приблизительных предсказаний,
касающихся производительности центрального процессора. Предположим,
к примеру, что память компьютера составляет 8 Гбайт, операционная система и ее
таблицы занимают до 2 Гбайт, а каждая пользовательская программа также занимает
до 2 Гбайт. Этот объем позволяет одновременно разместить в памяти три пользовательские
программы. При среднем ожидании ввода-вывода, составляющем 80 % времени,
мы имеем загруженность центрального процессора (если игнорировать издержки на
работу операционной системы), равную 1 – 0,8 3 , или около 49 %. Увеличение объема
памяти еще на 8 Гбайт позволит системе перейти от трехкратной многозадачности
к семикратной, что повысит загруженность центрального процессора до 79 %. Иными
словами, дополнительные 8 Гбайт памяти увеличат его производительность на 30 %.
Увеличение памяти еще на 8 Гбайт поднимет уровень производительности всего лишь
с 79 до 91 %, то есть дополнительный прирост производительности составит только
12 %. Используя эту модель, владельцы компьютеров могут прийти к выводу, что
первое наращивание объема памяти, в отличие от второго, станет неплохим вкладом
в повышение производительности процессора.