/**
 * Created by Admin on 19.03.2016.
 */
var FStems = function () {
    this.fs=[[],[],[],[],[]]; //5 стем
    //this.fs.length=3;
    this.number=0;
    //this.prev;

    this.addStem = function (stem) {
        var prev=this.fs[0];
        if(this.fs[4].length >= 5) {
            this.fs[4].shift();
            this.fs[4].push(stem);
        }
        else {
            if(this.fs[3].length==4) {
                this.fs[4].push(this.fs[3][0]);
                this.fs[4].push(this.fs[3][1]);
                this.fs[4].push(this.fs[3][2]);
                this.fs[4].push(this.fs[3][3]);
                this.fs[4].push(stem);
            }
        }
        if(this.fs[3].length >= 4) {
            this.fs[3].shift();
            this.fs[3].push(stem);
        }
        else{
            if(this.fs[2].length==3) {
                this.fs[3].push(this.fs[2][0]);
                this.fs[3].push(this.fs[2][1]);
                this.fs[3].push(this.fs[2][2]);
                this.fs[3].push(stem);
            }
        }
        if(this.fs[2].length >= 3) {
            this.fs[2].shift();
            this.fs[2].push(stem);
        }
        else{
            if(this.fs[1].length==2) {
                this.fs[2].push(this.fs[1][0]);
                this.fs[2].push(this.fs[1][1]);
                this.fs[2].push(stem);
            }
        }
        if(this.fs[1].length >= 2) {
            this.fs[1].shift();
            this.fs[1].push(stem);
        }
        else{
            if(this.fs[0].length==1) {
                this.fs[1].push(prev);
                this.fs[1].push(stem);
            }
        }
        this.fs[0]=stem;
        this.number=this.number+1;
    };
    this.print = function () {
        console.log('1 = >'+this.fs[0]);
        console.log('2 = >'+this.fs[1].join(' '));
        console.log('3 = >'+this.fs[2].join(' '));
        console.log('4 = >'+this.fs[3].join(' '));
        console.log('5 = >'+this.fs[4].join(' '));
    };
    this.getStems = function (n) {
        if(n!=0) {
            var args = Array.prototype.slice.call(this.fs[n]);
            return args.join(' ');
        } else
            return this.fs[0];
    };
};



// **************** HashArray **********************
var HashArray = function () {
    //Create JSON hash array.
    this.hash = {};

    this.add = function (key, value) {
        if (this.hash[key] === undefined)
            this.hash[key] = value;
    };

    this.clear = function () {
        this.hash = {};
    };

    this.get = function (key) {
        return this.hash[key];
    };

    this.set = function (key, value) {
        if (this.hash[key] !== undefined)
            this.hash[key] = value;
    };

    this.containsKey = function (key) {
        return this.hash[key] !== undefined;
    };

    this.containsValue = function (value) {
        for (var i in this.hash)
            if (this.hash.hasOwnProperty(i) && this.hash[i] === value)
                return true;
        return false;
    };

    this.toArray = function () {
        var arr = [];
        for (var i in this.Hash)
            if (this.Hash.hasOwnProperty(i))
                arr.push([i, this.Hash[i]]);
        return arr;
    };

    this.keys = function () {
        var array_keys = [];
        for (var key in this.hash) {
            array_keys.push(key);
        }
        return array_keys;
    };

    this.values = function () {
        var array_values = [];
        for (var key in this.hash) {
            array_values.push(this.hash[key]);
        }
        return array_values;
    };
};


// **************** DictStems **********************
//класс для хранения словарных стем
function DictStems(  ) {
    this.stems=new Array();
    this.addStem = function (stem) {
        function checkAvailability(arr, val) {
            return arr.some(function(arrVal) {
                return val === arrVal;
            });
        }
        if(!checkAvailability(this.stems, stem)) {
            //если отсутсвует
            this.stems.push(stem);
            return this.stems.length-1;
        }
        else {
            return this.stems.indexOf(stem);
        }
    };
    this.getLength = function () {
        return this.stems.length;
    };
    this.print = function () {
        var arr=[];
        for(var i=0; i<this.stems.length; i++){
            arr.push(i+"\t=>\t"+this.stems[i]);
        }
        return arr.join('\n');
        //return this.stems.join(';');
    }
}

// **************** ConceptAndStemValue **********************
function ConceptAndStemValue(c1, s1, n1 ){
    this.idConc=c1;
    this.idStem=s1;
    this.numbStems=n1;
    this.set = function (c, s, n) {
        this.idConc = c;
        this.idStem = s;
        this.numbStems = n;
    }
}

// **************** ConceptAndStemTable **********************
function ConceptAndStemTable( ){
    this.table=[];
    this.add = function (c, s, n) {
        var value = new ConceptAndStemValue(c, s, n);
        this.table.push(value);
        return this.table.length-1;
    };
    this.getLength = function () {
        return this.table.length;
    };
    this.print = function () {
        var arr=[];
        for(var i=0; i<this.table.length; i++){
            arr.push(i+"\t=>\t"+this.table[i].idConc+" \t "+this.table[i].idStem);
        }
        return arr.join('\n');
    }
}

// **************** DictConcepts **********************
function DictConcepts( ){
    this.concepts=new Array();
    this.addConcept = function (c) {
        function checkAvailability(arr, val) {
            return arr.some(function(arrVal) {
                return val === arrVal;
            });
        }
        if(!checkAvailability(this.concepts, c)) {
            //если отсутсвует
            this.concepts.push(c);
            return this.concepts.length-1;
        }
        else {
            return this.concepts.indexOf(c);
        }
    };
    this.getLength = function () {
        return this.concepts.length;
    };
    this.print = function () {
        var arr=[];
        for(var i=0; i<this.concepts.length; i++){
            arr.push(i+"\t=>\t"+this.concepts[i]);
        }
        return arr.join('\n');
    }
}

var isCyrillic = function (text) {
    return /[а-яА-Я]/i.test(text);
};

function intersection(A, B)
{
    var m = A.length, n = B.length, c = 0, C = [];
    for (var i = 0; i < m; i++)
    {
        var j = 0, k = 0;
        while (B[j] !== A[ i ] && j < n) j++;
        while (C[k] !== A[ i ] && k < c) k++;
        if (j != n && k == c) C[c++] = A[ i ];
    }
    return C;
};
function diff(A, B)
{
    var M = A.length, N = B.length, c = 0, C = [];
    for (var i = 0; i < M; i++)
    {
        var j = 0, k = 0;
        while (B[j] !== A[i] && j < N) j++;
        while (C[k] !== A[i] && k < c) k++;
        if (j == N && k == c) C[c++] = A[i];
    }
    return C;
}
function getMostFreqTokens(A){
    A.sort();
    var current = null;
    var res = [];
    var cnt = 0;
    var out = '';
    for (var i = 0; i < A.length; i++) {
        if (A[i] != current) {
            if (cnt > 0) {
                out += current + '  --> ' + cnt + '  \r\n';
                if(cnt>1)
                    res.push(current);
            }
            current = A[i];
            cnt = 1;
        } else {
            cnt++;
        }
    }
    if (cnt > 0) {
        out += current + '  --> ' + cnt + ' ';
        if(cnt>1)
            res.push(current);
    }
    //console.log('getMostFreqTokens #' + out);
    return res;
}

// ***************************** findCorrectWord **************************************
var stopWordRuFile = './etc/files/stop_ru.txt';
var stopWordEngFile = './etc/files/stop_eng.txt';
var punctFile = './etc/files/punct.txt';
fs = require('fs');
var stopWordRu = fs.readFileSync(stopWordRuFile,'utf8').toString().split('\n');
var stopWordEng = fs.readFileSync(stopWordEngFile,'utf8').toString().split('\n');
var punct = fs.readFileSync(punctFile,'utf8').toString().split('\n');
//console.log('stopWordRu count:');
//console.log(stopWordRu.length);
//console.log(stopWordRu.join('\n'));
//console.log(punct.join('\n'));
//функция-фильтр - оставляет только значимые слова - для стоп-слов и пунктуции возвращает false
var findCorrectWord = function(item) {
    var punct1 = '\\[' + '\\!' + '\\"' + '\\#' + '\\$'  + // since javascript does not
            '\\%' + '\\&' + '\\\'' + '\\(' + '\\)' + // support POSIX character
            '\\*' + '\\+' + '\\,' + '\\\\' + '\\-' + // classes, we'll need our
            '\\.' + '\\/' + '\\:' + '\\;' + '\\<'  + // own version of [:punct:]
            '\\=' + '\\>' + '\\?' + '\\@' + '\\['  +
            '\\]' + '\\^' + '\\_' + '\\`' + '\\{'  +
            '\\|' + '\\}' + '\\~' + '\\]' + '\\»' +
            "\\«" + '\\—' + '\\‘' + '\\’',

        re = new RegExp( // tokenizer
            '\\s*' +           // discard possible leading whitespace
            '(' +              // start capture group #1
            '[' + punct1 + ']+' +  // punct
            ')\\s*' // end capture group #1
        );
    if(re.test(item))
        return false;
    //if(punct.indexOf(item) != -1)
    //    return false;
    if(isCyrillic(item))
        return stopWordRu.indexOf(item) == -1;
    else
        return stopWordEng.indexOf(item) == -1;
}


// ***************************** findStemsInDict **************************************
// Выбирает максимально длинную стему находящуюся в tokens из в dict
//var tokens=['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'B', 'B', '.'];
//var dict={};
//dict['B']='B';
//dict['B C']='B C';
//dict['E']='E';
//dict['E F G']='E F G';
//dict['G H']='G H';
var findStemsInDict = function(tokens, dict){
    this.findStems = new FStems();
    this.prevStems = [];
    this.founded = 0;
    this.prevFounded=0;
    this.res={};
    for (var i = 0; i < tokens.length; i++) {
        var stem=tokens[i];
        this.findStems.addStem(stem);
        for( var jj = 0; jj < 5; jj++){
            if(this.findStems.fs[jj].length > 0) {
                //var cs = [];
                var cs = this.findStems.getStems(jj);
                //console.log('cs= '+cs);
                if (dict[cs] !== undefined) {
                    this.founded = this.founded | (1<<jj);
                    //console.log('+f= '+cs);
                }
                else {
                    this.founded = this.founded & ~(1<<jj);
                    //console.log('-f= '+cs);
                }
            }
        }
        //findStems.print();
        if(/*this.prevFounded!=0 && this.founded!=0
            &&*/ this.founded <= this.prevFounded){
            //console.log('push= ' + prevFounded.toString(2));
            //console.log('prevStems= ' + prevStems.join(', '));
            jj=0;
            while(jj<5){
                /*if(jj==0) {
                    if(((this.prevFounded) & 1) == 1) {
                        var fff = this.prevStems[jj];
                        var ff = dict[fff];
                        console.log('0= ' + ff);
                        if (this.res[ff] === undefined)
                            this.res[ff] = 0;
                        this.res[ff] += +1;
                        break;
                    }
                    else
                        jj++;
                } else*/ if(((this.prevFounded >> jj) & 1) == 1){
                    var fff= this.prevStems[jj];
                    var ff= dict[fff];
                    //console.log(jj + '= ' + ff);
                    if(this.res[ff] === undefined)
                        this.res[ff]=0;
                    this.res[ff]+=+1;
                    break;
                }
                else
                    jj++;
            }
        }
        this.prevFounded=this.founded;
        for( jj = 0; jj < 5; jj++){
            this.prevStems[jj]=this.findStems.getStems(jj);
        }
        //console.log(stem+'=>'+founded.toString(2));
        //console.log('res'+'=>'+'\n');
        //for(var k in res){
        //    console.log( k + " => " + res[k]);
        //}
    }//end for
    return this.res;
};
//var res = findStemsInDict(tokens, dict);
//console.log('res'+'=>'+'\n');
//for(var k in res){
//    console.log( k + " => " + res[k]);
//}


var natural = require('natural');
var tokenizer1 = require('Tokenizer');
stemmer = natural.PorterStemmerRu;
stemmerEng = natural.PorterStemmer;
var filename = './etc/files/tanen_index_all_mod_new.txt';
var dict1 = fs.readFileSync(filename,'utf8').toString().split('\n');
var myDict1Stems = new DictStems();
var myDictConcepts = new DictConcepts();
var myConceptAndStemTable = new ConceptAndStemTable();
var hashDict = {};
var dict1Stems = dict1.map(function(item) {
    var idConc = myDictConcepts.addConcept(item);
    var idStem;
    var stem;
    var words1=item.split(' ');
    if(words1.length==0)
        return '';
    //var words1=tokenizer1(item);
    if(words1.length==1){
        if(isCyrillic(item)) {
            idStem= myDict1Stems.addStem(stemmer.stem(item));
            stem= stemmer.stem(item);
            stem.replace( / /gi, '');
            hashDict[stem]=item;
        }
        else {
            idStem= myDict1Stems.addStem(stemmerEng.stem(item));
            stem=  stemmerEng.stem(item);
            stem.replace( / /gi, '');
            hashDict[stem]=item;
        }
        myConceptAndStemTable.add(idConc, idStem, 1);
    }
    else {
        var itemHash=[];
        for(var i=0; i<words1.length; i++)
        {
            var word=words1[i];
            if(isCyrillic(word)) {
                stem= stemmer.stem(word);
                idStem= myDict1Stems.addStem(stem);
            }
            else {
                stem=  stemmerEng.stem(word);
                idStem= myDict1Stems.addStem(stem);
            }
            itemHash.push(stem);
            myConceptAndStemTable.add(idConc, idStem, words1.length);
        }
        stem= '';
        hashDict[itemHash.join(' ')]=item;
    }

    return stem;
});
var parseFile = function (data, res, filename) {
    var taTokens3 =  tokenizer1(data).filter(findCorrectWord);
    for ( i = 0; i < taTokens3.length; i++) {
        if(isCyrillic(taTokens3[i]))
            taTokens3[i] = stemmer.stem(taTokens3[i]);
        else
            taTokens3[i] = stemmerEng.stem(taTokens3[i]);
    }
    var ress = findStemsInDict(taTokens3, hashDict);
    var myKeys =  intersection(taTokens3, myDict1Stems.stems);
    var keysRess = [];
    var valuesRess = [];
    for (var key in ress) {
        keysRess.push(key);
        valuesRess.push(ress[key]);
    }
    var keysAndFreqs=new Array(keysRess.length);
    for(i = 0; i < keysRess.length; i++) {
        keysAndFreqs[i]=new Array(2);
        keysAndFreqs[i][0]=keysRess[i];
        keysAndFreqs[i][1]=valuesRess[i];
    }
    var keysAndFreqs2=new Array();
    for(i = 0; i < myKeys.length; i++) {
        var arr = new Array(2);
        arr[0]=myKeys[i];
        var indices = 0;
        var element = myKeys[i];
        if(element.length <= 3)
            continue;
        var idx = taTokens3.indexOf(element);
        while (idx != -1) {
            indices=indices+1;
            idx = taTokens3.indexOf(element, idx + 1);
        }
        arr[1]=indices;
        keysAndFreqs2.push(arr);
    }
    // Сортировка по частоте
    keysAndFreqs.sort(function(a, b) {
        if (a[1] < b[1]) return 1;
        else if (a[1] > b[1]) return -1;
        else return 0;
    });
    keysAndFreqs2.sort(function(a, b) {
        if (a[1] < b[1]) return 1;
        else if (a[1] > b[1]) return -1;
        else return 0;
    });
    res.render('analyze', {
        title: 'Tag Annotation Service',
        text1: data,
        pKeysOrigAndFreq: keysAndFreqs,
        tokenText1: taTokens3,
        pKeysAndFreq2: keysAndFreqs2
    });
    console.log('success finish: '+filename);
}

//module.exports.dict1 = dict1;
//module.exports.myDict1Stems = myDict1Stems;
//module.exports.myConceptAndStemTable = myConceptAndStemTable;
//module.exports.hashDict = hashDict;
//module.exports.dict1Stems = dict1Stems;
module.exports.parseFile = parseFile;
module.exports.FStems = FStems;
module.exports.HashArray = HashArray;
module.exports.DictStems = DictStems;
module.exports.DictConcepts = DictConcepts;
module.exports.ConceptAndStemTable = ConceptAndStemTable;
module.exports.ConceptAndStemValue = ConceptAndStemValue;
module.exports.isCyrillic = isCyrillic;
module.exports.intersection = intersection;
module.exports.diff = diff;
module.exports.getMostFreqTokens = getMostFreqTokens;
module.exports.findCorrectWord = findCorrectWord;
module.exports.findStemsInDict = findStemsInDict;